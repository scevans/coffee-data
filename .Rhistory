}
rm(data)
ManySpiders <- cmpfun(function(nrep, env, size, web, batch)
{
set.seed(batch)
mclapply(rep.int(size, nrep), function(x) StochasticModel(env, initSpiderMass=x, webDensity=web),
mc.cores=numCores, mc.set.seed=TRUE, mc.preschedule=opts)
})
require(ggplot2)
install.packages("ggplot2")
require(data.table)
install.packages("data.table")
ggplot()
?pca
install.packages("pcamethods")
install.packages("bpca")
?bpca
require(bpca)
?scatterplot3d
require(dplyr)
install.packages("dplyr")
require(dplyr)
require(plyr)
library(ggplot2)
require(ggplot2)
detach(ggplot2)
detach("ggplot2")
?detach
detach(ggplot2, unload=T)
search()
detach(package:ggplot2)
search()
require(ggplot2)
search()
search()
library(plyr)
require(plyr)
detach(package:plyr)
require(plyr)
detach(package:plyr)
require(dplyr)
require(plyr)
detach(package:plyr)
detach(package:dplyr)
require(plyr)
require(dplyr)
require(dplyr)
df <- matrix(nrow=10, ncol=4)
df[,1] <- runif(1,0,1)
df[,1] <- runif(10,0,1)
df[,2] <- runif(10,50,60)
df[,3] <- c(rep("a", 5), rep("b", 5))
df[,4] <- 1:10
head(df)
df <- as.data.frame(df)
sapply(df, class)
df[,1:2] <- as.numeric(df[,1:2])
names(df) <- c("x", "y", "cat", "spec")
df$x <- as.numeric(df$x)
df$y <- as.numeric(df$y)
df$spec <- as.integer(df$spec)
sapply(df, class)
new <- ddply(df, "cat", summarize, x=mean(x), y=mean(y), spec=sum(spec))
new <- summarize(group_by(cat), x=mean(x), y=mean(y), spec=sum(spec))
new <- summarize(group_by(df, cat), x=mean(x), y=mean(y), spec=sum(spec))
new
df
df <- matrix(nrow=10, ncol=4)
df[,1] <- runif(10,0,1)
df[,2] <- runif(10,50,60)
df[,3] <- c(rep("a", 5), rep("b", 5))
df[,4] <- 1:10
head(df)
df <- as.data.frame(df)
df
names(df) <- c("x", "y", "cat", "spec")
df$x <- as.numeric(df$x)
df
?data.frame
require(knitr)
install.packages("knitr")
ophrys <- read.csv("~/Downloads/RSEMisoforms.csv")
library(data.table)
i <- 1
genes <- as.data.frame(unique(ophrys$gene_id)) # vector of gene IDs
names(genes) <- "gene.id"
n <- length(genes$gene.id)
d <- matrix(0, nrow=n, ncol=8) # df to hold all rows of ophrys containing desired transcript IDs
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[i,] <- temp[1,]
i <- i + 1
})
d <- matrix(0, nrow=n, ncol=8) # df to hold all rows of ophrys containing desired transcript IDs
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[i] <- temp[1,]
i <- i + 1
}) # takes a while because loops are very slow in R...
d[3]
temp[1]
d[i] <- temp[1]
d[i]
d <- matrix(0, nrow=n, ncol=8) # df to hold all rows of ophrys containing desired transcript IDs
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[i] <- temp[1]
i <- i + 1
}) # takes a while because loops are very slow in R...
d
View(d)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
temp
temp[1]
i <- 875
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
temp
temp <- temp[with(temp, order(-FPKM)),]
temp
temp[1]
temp[1,1]
sapply(temp, class)
ophrys$transcript_id <- as.character(ophrys$transcript_id)
d <- list()
temp[1]
temp[1,1]
?as.string
?as.String
as.str
?as.str
?str
str(temp[1,1])
ophrys$transcript_id <- as.character(ophrys$transcript_id)
i <- 875
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
temp <- temp[with(temp, order(-FPKM)),]
temp[1,1]
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- temp[1,1]
i <- i + 1
}) # takes a while because loops are very slow in R...
i <- 1
d <- list()
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- temp[1,1]
i <- i + 1
}) # takes a while because loops are very slow in R...
data <- as.data.frame(rbindlist(d))
as.data.frame(temp[1,1])
i <- 1
i <- 1
d <- list()
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- as.data.frame(temp[1,1])
i <- i + 1
}) # takes a while because loops are very slow in R...
data <- as.data.frame(rbindlist(d))
View(data)
transcripts <- as.data.frame(rbindlist(d))
names(transcripts) <- "transcripts"
View(data)
rm(list=ls())
ophrys <- read.csv("~/Downloads/RSEMisoforms.csv")
# transform transcript IDs' type from factor to character
ophrys$transcript_id <- as.character(ophrys$transcript_id)
library(data.table)
# create vector of unique gene IDs
genes <- as.data.frame(unique(ophrys$gene_id))
names(genes) <- "gene.id"
n <- length(genes$gene.id)
i <- 1 # index
d <- list() # list for storing transcript IDs
system.time(while (i <= n) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- as.data.frame(temp[1,1])
i <- i + 1
}) # takes a while because loops are very slow in R...
transcripts <- as.data.frame(rbindlist(d))
names(transcripts) <- "transcripts"
View(transcripts)
write.csv(transcripts, file="transcript-ids.csv", row.names=FALSE, fileEncoding="UTF-8")
getwd()
install.packages("knitr")
require(Rmd)
install.packages("Rmd")
install.packages("Rmarkdown")
require(md)
install.packages("md")
require(rmarkdown)
install.packages("rmarkdown")
install.packages("pandoc")
require(pandoc)
install.packages("markdown")
require(markdown)
require(markdown)
?md
?markdown
setwd("~/aussie-astioids")
getwd()
setwd()
H
getwd()
getwd()
setwd("/home/sam")
getwd()
install.packages("png")
install.packages("jpeg")
?jpeg
require(jpeg)
require(meme)
require(memes)
install.packages("memes")
install.packages("meme")
if(!require("devtools")) install.packages("devtools")
library("devtools")
install_github("leeper/meme")
install.packages("devtools")
library("meme")
require("devtools")
install.packages("curl-dev")
install.packages("curl-devel")
require(ggplot2)
?shape
?scale_color_manual
attributes(cars)
TRUE <- 1
T <- 1
T
T <- FALSE
T
is.true(T)
typeof(T)
x <- c(34,45,32,7)
x(c(-1,-2))
x[c(-1,-2)]
y <- 10
f1 <- function(x) {
function() {
x + 10
}
}
f1(1)()
f1(1)
f1(1)()
f1()(1)
f1(1)(1)
f1(1)()
?typeof
?is.list()
?sd
PREY_L <- vector(mode="numeric", length=50)
PREY_L <- seq(1,100,1)
PREY_L <- rep(PREY_L, 2)
PREY_L <- sort(PREY_L)
PREY_L <- vector(mode="numeric", length=50)
PREY_L <- seq(2,100,2)
PREY_L <- rep(PREY_L, 2)
PREY_L <- sort(PREY_L)
library(data.table)
?rbindlist
?sweep
### How does the espresso machine vary in the volume of
### coffee it dispenses for a single "large" cup?
setwd("/home/sam/Dropbox/github/coffee-data")
#setwd("wherever you put this file after downloading it")
library(ggplot2)
df <- read.csv("coffee-data.csv")
# sample size
n <- length(df$duration)
# label to print sample size in subsequent plot
n.text <- paste("n == ", n)
# data.frame of sample size label and coordinates
# at which to print it on the plot
n.df <- data.frame(n.text, x=min(df$duration), y=0.87*max(df$volume))
################################
### Volume vs. duration (duration of coffee dispensation)
{
# calculate R-squared value
rsq <- signif(summary(lm(df$volume ~ df$duration))$r.squared, digits=3)
# make a label to print R-squared value in subsequent plot
rsq.text <- paste("R^2 == ",rsq)
# make a data.frame of R-squared value label and coordinates
# at which to print it on the plot
rsq.df <- data.frame(rsq.text,x=min(df$duration),y=0.9*max(df$volume))
# function to extract regression equation
lm_eqn <- function(df)
{
m <- lm(df$volume ~ df$duration)
eq <- substitute(y == a + b*x,
list(a = format(coef(m)[1], digits = 2),
b = format(coef(m)[2], digits = 2)))
as.character(as.expression(eq))
}
# generate plot w/ simple linear regression overlayed
plot <- ggplot(df, aes(duration, volume)) +
geom_point() +
stat_smooth(method="lm") +
xlab("duration of coffee dispensation (seconds)") +
ylab("volume of one large cup (ml)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
theme_bw()
# add regression equation to plot
plot <- plot +
geom_text(data=n.df, aes(x,y,label=n.text),parse=TRUE,hjust=0,vjust=0,size=5) +
geom_text(data=rsq.df, aes(x,y,label=rsq.text),parse=TRUE,hjust=0,vjust=0,size=5) +
geom_text(aes(x=min(df$duration),y=0.94*max(df$volume),label=lm_eqn(df)),parse=TRUE,hjust=0,vjust=0,size=5)
# add a layer that highlights the last data point recorded
#plot <- plot +
#  geom_point(data=df[length(df$duration),],color="red",size=2.5)
# add a layer that highlights data points where espresso machine
# had to "warm up" before dispensing coffee
plot <- plot +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x=mean(df$duration)-5,y=min(df$volume),label="(machine warmup before dispensed)"),
hjust=0,vjust=0.5,color="red",size=4)
# print plot in R window
plot
# save plot directly to file as a .jpeg
jpeg("coffee-volume-vs-duration.jpeg", width=7, height=5, units="in", res=300)
print(plot)
dev.off()
}
################################
### Distributions of volume dispensed: weekdays vs. weekends
{
df$workday <- factor(df$workday)
# median volumes for weekday and weekend categories
med.week <- median(df$volume[df$workday%in%"Mon-Fri"])
med.wkend <- median(df$volume[df$workday%in%"Sat-Sun"])
# generate violin-and-boxplot plot with points overlayed and jittered to better reflect sample size
vol.workday <- ggplot(df, aes(workday, volume)) +
geom_violin(color="white", fill="gray", alpha=0.85)
# add layer highlighting points where espresso machine needed to
# "warm up" before dispensing coffee
vol.workday <- vol.workday +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x="Sat-Sun", y=max(df$volume)+10, label="(machine warmup before dispensed)"),
hjust=1,vjust=1,size=4,color="red") +
geom_text(aes(x="Sat-Sun", y=max(df$volume)+4, label="(median)"),
hjust=1,vjust=1,size=4,color="blue") +
#geom_point(position=position_jitter(width=0.1,height=0)) +
# plot points representing median volumes for weekdays and weekends
geom_point(aes(x="Mon-Fri",y=med.week),color="blue",size=2.5) +
geom_point(aes(x="Sat-Sun",y=med.wkend),color="blue",size=2.5) +
xlab("time of the week") +
ylab("volume of one large cup (ml)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
coord_cartesian(ylim=c(min(df$volume)-5,max(df$volume)+30)) +
theme_bw()
# add sample sizes for weekdays and weekends
vol.workday <- vol.workday +
geom_text(aes(x="Mon-Fri",y=max(df$volume)+15,
label=paste("n == ", length(df$workday[which(df$workday%in%"Mon-Fri")]))),
parse=TRUE,hjust=0.5,vjust=0,size=5) +
geom_text(aes(x="Sat-Sun",y=max(df$volume)+15,
label=paste("n == ", length(df$workday[which(df$workday%in%"Sat-Sun")]))),
parse=TRUE,hjust=0.5,vjust=0,size=5)
# print plot in R window
vol.workday
# save plot to file as .jpeg
jpeg("coffee-volume-by-workday.jpeg", width=7, height=5, units="in", res=300)
print(vol.workday)
dev.off()
}
################################
### Distributions of volume dispensed by day
{
df$day <- factor(df$day,levels=c("Mon","Tue","Wed","Thu","Fri","Sat","Sun"))
median.by.day <- data.frame(c("Mon","Tue","Wed","Thu","Fri","Sat","Sun"),
c(0,0,0,0,0,0,0),
c(0,0,0,0,0,0,0))
names(median.by.day) <- c("day", "median.volume", "n")
for (i in 1:7)
{
median.by.day$median.volume[i] <- median(df$volume[df$day%in%median.by.day$day[i]])
median.by.day$n[i] <- length(df$volume[df$day%in%median.by.day$day[i]])
}
# generate violin-and-boxplot plot with points overlayed and jittered to better reflect sample size
vol.day <- ggplot(df, aes(day, volume)) +
geom_violin(color="white", fill="gray", alpha=0.85) +
geom_point()
# add layer highlighting points where espresso machine needed to
# "warm up" before dispensing coffee
vol.day <- vol.day +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x="Sat", y=max(df$volume)+16, label="(machine warmup before dispensed)"),
hjust=1,vjust=1,size=4,color="red") +
geom_text(aes(x="Tue", y=max(df$volume)+16, label="(median)"),
hjust=1,vjust=1,size=4,color="blue") +
#geom_point(position=position_jitter(width=0.1,height=0)) +
# plot points representing median volumes for weekdays and weekends
geom_point(data=median.by.day, aes(day,median.volume),color="blue",size=2.5) +
xlab("day of the week") +
ylab("volume of one large cup (ml)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
coord_cartesian(ylim=c(min(df$volume)-5,max(df$volume)+20)) +
theme_bw()
# add sample sizes for weekdays and weekends
vol.day <- vol.day +
geom_text(data=median.by.day, aes(day,y=max(df$volume)+4),
label=paste("(", median.by.day$n, ")", sep=""),
parse=TRUE,hjust=0.5,vjust=0,size=4)
# print plot in R window
vol.day
# save plot to file as .jpeg
jpeg("coffee-volume-by-day.jpeg", width=8, height=5, units="in", res=300)
print(vol.day)
dev.off()
}
################################
### Volume vs. duration (duration of coffee dispensation)
### EXCLUDING instances where machine had to warm up
{
# subset df by removing machine warmup rows
# (this is a quick-and-dirty way, and not an advisable habit for handling data)
df <- df[df$warmup%in%"no",]
# recalculate sample size
n <- length(df$duration)
# label to print sample size in subsequent plot
n.text <- paste("n == ", n)
# data.frame of sample size label and coordinates
# at which to print it on the plot
n.df <- data.frame(n.text, x=min(df$duration), y=0.87*max(df$volume))
# calculate R-squared value
rsq <- signif(summary(lm(df$volume ~ df$duration))$r.squared, digits=3)
# make a label to print R-squared value in subsequent plot
rsq.text <- paste("R^2 == ",rsq)
# make a data.frame of R-squared value label and coordinates
# at which to print it on the plot
rsq.df <- data.frame(rsq.text,x=min(df$duration),y=0.9*max(df$volume))
# function to extract regression equation
lm_eqn <- function(df)
{
m <- lm(df$volume ~ df$duration)
eq <- substitute(y == a + b*x,
list(a = format(coef(m)[1], digits = 2),
b = format(coef(m)[2], digits = 2)))
as.character(as.expression(eq))
}
# generate plot w/ simple linear regression overlayed
plot.no.warmup <- ggplot(df, aes(duration, volume)) +
geom_point() +
stat_smooth(method="lm") +
xlab("duration of coffee dispensation (seconds)") +
ylab("volume of one large cup (ml)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
theme_bw()
# add regression equation to plot
plot.no.warmup <- plot.no.warmup +
geom_text(data=n.df, aes(x,y,label=n.text),parse=TRUE,hjust=0,vjust=0,size=5,color="blue") +
geom_text(data=rsq.df, aes(x,y,label=rsq.text),parse=TRUE,hjust=0,vjust=0,size=5) +
geom_text(aes(x=min(df$duration),y=0.94*max(df$volume),label=lm_eqn(df)),parse=TRUE,hjust=0,vjust=0,size=5)
# add a layer that highlights the last data point recorded
#plot <- plot +
#  geom_point(data=df[length(df$duration),],color="red",size=2.5)
# add a layer that highlights data points where espresso machine
# had to "warm up" before dispensing coffee
plot.no.warmup <- plot.no.warmup +
geom_text(aes(x=mean(df$duration)-5,y=min(df$volume),label="(machine warmup data points removed)"),
hjust=0,vjust=0.5,color="blue",size=4)
# print plot in R window
plot.no.warmup
# save plot directly to file as a .jpeg
jpeg("coffee-volume-vs-duration-excluding-warmup-data.jpeg", width=7, height=5, units="in", res=300)
print(plot.no.warmup)
dev.off()
}
