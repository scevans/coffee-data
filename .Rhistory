# 3 = "large-biased"
data[,2] <- initSpiderMass # initial spider mass
data[,8] <- PREY_L # prey size classes (lengths, in mm)
## PART 2: LOOP SIMULATING A DAY IN THE LIFE OF A SPIDER
# This is the main component of the StochasticModel function,
# where spider foraging is simulated. The loop iterates until
# the spider starves to death or forages for 30 days.
while (day <= numDays && spiderMass >= starve) {
spiderMassDay <- spiderMass # spider mass at beginning of the current day
## WEB CHARACTERISTICS, calculated from Sensenig et al. 2010 JEB data
# Each day, the spider builds a new web with characteristics calculated
# below, according to its mass at the beginning of the day.
webArea <- 10^(0.3135 * log(spiderMass, base=10) + 1.93) * webDensity # cm^2
silkVolume <- 10^(-3.02 + 0.805 * log(spiderMass, base=10)) # mm^3
threadThickness <- 10^(-0.696 + 0.717 * log(spiderMass, base=10)) # um^2
captureThreadLength <- 0.5 * (silkVolume / (threadThickness * 10^-6)) # mm
meshWidth <- (10 * (0.9 * sqrt(webArea / pi))) /
((captureThreadLength / 10) / (pi * (0.9 * sqrt(webArea / pi)) - 1)) # mm
silkToughness <- 10^(2 + (0.13 * log(spiderMass, base=10))) * 10^3 # uJ
##
# Number of "events" (i.e. prey to be encountered) for the day
numEventsDay <- round((webArea / 1000) * NUM_PREY[env])
numEventsLife <- numEventsLife + numEventsDay
## PREY CAPTURE PROBABILITIES FOR EACH CAPTURE STAGE
contact <- PREY_L / meshWidth
contact[contact>1] <- 1
stopping <- (silkVolume * silkToughness) / (4.0 * PREY_KE)
stopping[PREY_SA > webArea/4]  <- {((silkVolume * silkToughness) /
((webArea / PREY_SA[PREY_SA > webArea/4])
* PREY_KE[PREY_SA > webArea/4]))}
# CAUTION: the above stopping function might return an error on some platforms
# (e.g. occasionally when running from a script window in base R).
# This is usually because the platform is confused by the equation being on
# multiple lines. I have put the equation in brackets, which should solve this
# problem, but if you get an error, just re-run the stochastic model
# with this function on a single line.
stopping[stopping>1] <- 1
retention <- 10 * (1 / PREY_KEA) * PREY_L / meshWidth
retention[retention>1] <- 1
##
# Number of each prey size expected to be encountered during the day.
# (Remember that, because this is a stochastic model,
# spiders can encounter more or fewer prey of a certain size
# relative what would be probabilistically expected)
data[,9] <- data[,9] + (PREY.A[,env] * numEventsDay)
## LOOP: PREY CAPTURE EVENT
# This loop simulates each prey capture event.
# i) The spider encounters a prey item;
# ii) the prey item either escapes or contacts the web;
# iii) if contacted, the prey item either escapes or is stopped by web;
# iv) if stopped, the
# prey item either escapes or is retained by web,
# v) if retained, the spider gets a meal (20% of the prey's mass).
# Spiders lose a little bit of mass every event, regardless of
# prey capture success/failure.
# The loop moves on to simulate the next event when the prey either escapes
# or is captured. The loop ends when all the prey for the day have been encountered.
for(i in 1:numEventsDay){
# Calculates metabolic cost for the event
metabolicCost <- (spiderBLC * spiderMass^spiderBLE) / (numDays * numEventsDay)
# Randomly selects prey item for the event,
# based on the prey abundance distribution in the environment.
rn <- runif(1, 0, 1) # random number between 0 and 1
#
itemL <- PREY_L[which(PREY.CA[,env] >= rn)[1]]
itemM <- PREY_M[itemL-min.preymm] # sets the mass of this prey item
# Counts the number of prey of this size
# that the spider's web has encountered
data[itemL-min.preymm,10] <- data[itemL-min.preymm,10] + 1
# Updates the number of prey of this size *expected* to be contacted
data[itemL-min.preymm,11] <- data[itemL-min.preymm,11] + contact[itemL-min.preymm]
## Prey capture process (contact, stopping, retention)
rn <- runif(1, 0, 1) # random number to be used in deciding contact
# if web contacts prey item
if(contact[itemL-min.preymm] > rn){
# Updates the number of prey of this size that
# the spider's web has successfully contacted.
data[itemL-min.preymm,12] <- data[itemL-min.preymm,12] + 1
# Updates the number of prey of this size *expected* to be stopped
data[itemL-min.preymm,13] <- data[itemL-min.preymm,13] + stopping[itemL-min.preymm]
rn <- runif(1, 0, 1)
# if web stops prey item
if(stopping[itemL-min.preymm] > rn){
# Updates the number of prey of this size that
# the spider's web has successfully stopped.
data[itemL-min.preymm,14] <- data[itemL-min.preymm,14] + 1
# Updates expected number retained
data[itemL-min.preymm,15] <- data[itemL-min.preymm,15] + retention[itemL-min.preymm]
rn <- runif(1, 0, 1)
# if web retains prey item
if(retention[itemL-min.preymm] > rn){
# Updates the number of prey of this size that
# the spider's web has successfully captured
data[itemL-min.preymm,16] <- data[itemL-min.preymm,16] + 1
# Checks for largest prey captured
data[,17] <- max(c(itemL, data[1,17]))
# Updates spider mass
spiderMass <- (spiderMass - metabolicCost) + (itemM * spiderAE)
maxSpiderMass <- max(spiderMass, maxSpiderMass)
}else{ # if web does not retain prey
spiderMass <- (spiderMass - metabolicCost)
minSpiderMass <- min(spiderMass, minSpiderMass)
}
}else{ # if web does not stop prey
spiderMass <- (spiderMass - metabolicCost)
minSpiderMass <- min(spiderMass, minSpiderMass)
}
}else{ # if web does not contact prey
spiderMass <- (spiderMass - metabolicCost)
minSpiderMass <- min(spiderMass, minSpiderMass)
} # EVENT ENDS
# Adjusts the starving threshold for the end of the event
starve <- starve + (spiderGR * ((initSpiderMass / numDays) / numEventsDay));
} # DAY ENDS
day <- day + 1
} # ENDS WHEN SPIDER STARVES OR 30 DAYS HAVE PASSED
### Record data
data[,3] <- spiderMass # final mass
data[,4] <- minSpiderMass
data[,5] <- maxSpiderMass
data[,6] <- day
data[,7] <- round(max(0, (spiderMass - initSpiderMass))
/ 10^(0.4373 * log(initSpiderMass, base=10) - 1.1747)) # number of eggs
# num.eggs.dbc <- round(max(0, (spiderMassDBC - starve))
#                       / 10^(0.4373 * log(initSpiderMass, base=10) - 1.1747))
data <- as.data.frame(data)
data
}
rm(data)
ManySpiders <- cmpfun(function(nrep, env, size, web, batch)
{
set.seed(batch)
mclapply(rep.int(size, nrep), function(x) StochasticModel(env, initSpiderMass=x, webDensity=web),
mc.cores=numCores, mc.set.seed=TRUE, mc.preschedule=opts)
})
require(ggplot2)
install.packages("ggplot2")
require(data.table)
install.packages("data.table")
ggplot()
?pca
install.packages("pcamethods")
install.packages("bpca")
?bpca
require(bpca)
?scatterplot3d
require(dplyr)
install.packages("dplyr")
require(dplyr)
require(plyr)
library(ggplot2)
require(ggplot2)
detach(ggplot2)
detach("ggplot2")
?detach
detach(ggplot2, unload=T)
search()
detach(package:ggplot2)
search()
require(ggplot2)
search()
search()
library(plyr)
require(plyr)
detach(package:plyr)
require(plyr)
detach(package:plyr)
require(dplyr)
require(plyr)
detach(package:plyr)
detach(package:dplyr)
require(plyr)
require(dplyr)
require(dplyr)
df <- matrix(nrow=10, ncol=4)
df[,1] <- runif(1,0,1)
df[,1] <- runif(10,0,1)
df[,2] <- runif(10,50,60)
df[,3] <- c(rep("a", 5), rep("b", 5))
df[,4] <- 1:10
head(df)
df <- as.data.frame(df)
sapply(df, class)
df[,1:2] <- as.numeric(df[,1:2])
names(df) <- c("x", "y", "cat", "spec")
df$x <- as.numeric(df$x)
df$y <- as.numeric(df$y)
df$spec <- as.integer(df$spec)
sapply(df, class)
new <- ddply(df, "cat", summarize, x=mean(x), y=mean(y), spec=sum(spec))
new <- summarize(group_by(cat), x=mean(x), y=mean(y), spec=sum(spec))
new <- summarize(group_by(df, cat), x=mean(x), y=mean(y), spec=sum(spec))
new
df
df <- matrix(nrow=10, ncol=4)
df[,1] <- runif(10,0,1)
df[,2] <- runif(10,50,60)
df[,3] <- c(rep("a", 5), rep("b", 5))
df[,4] <- 1:10
head(df)
df <- as.data.frame(df)
df
names(df) <- c("x", "y", "cat", "spec")
df$x <- as.numeric(df$x)
df
?data.frame
require(knitr)
install.packages("knitr")
ophrys <- read.csv("~/Downloads/RSEMisoforms.csv")
library(data.table)
i <- 1
genes <- as.data.frame(unique(ophrys$gene_id)) # vector of gene IDs
names(genes) <- "gene.id"
n <- length(genes$gene.id)
d <- matrix(0, nrow=n, ncol=8) # df to hold all rows of ophrys containing desired transcript IDs
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[i,] <- temp[1,]
i <- i + 1
})
d <- matrix(0, nrow=n, ncol=8) # df to hold all rows of ophrys containing desired transcript IDs
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[i] <- temp[1,]
i <- i + 1
}) # takes a while because loops are very slow in R...
d[3]
temp[1]
d[i] <- temp[1]
d[i]
d <- matrix(0, nrow=n, ncol=8) # df to hold all rows of ophrys containing desired transcript IDs
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[i] <- temp[1]
i <- i + 1
}) # takes a while because loops are very slow in R...
d
View(d)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
temp
temp[1]
i <- 875
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
temp
temp <- temp[with(temp, order(-FPKM)),]
temp
temp[1]
temp[1,1]
sapply(temp, class)
ophrys$transcript_id <- as.character(ophrys$transcript_id)
d <- list()
temp[1]
temp[1,1]
?as.string
?as.String
as.str
?as.str
?str
str(temp[1,1])
ophrys$transcript_id <- as.character(ophrys$transcript_id)
i <- 875
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
temp <- temp[with(temp, order(-FPKM)),]
temp[1,1]
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- temp[1,1]
i <- i + 1
}) # takes a while because loops are very slow in R...
i <- 1
d <- list()
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- temp[1,1]
i <- i + 1
}) # takes a while because loops are very slow in R...
data <- as.data.frame(rbindlist(d))
as.data.frame(temp[1,1])
i <- 1
i <- 1
d <- list()
system.time(while (i <= 200) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- as.data.frame(temp[1,1])
i <- i + 1
}) # takes a while because loops are very slow in R...
data <- as.data.frame(rbindlist(d))
View(data)
transcripts <- as.data.frame(rbindlist(d))
names(transcripts) <- "transcripts"
View(data)
rm(list=ls())
ophrys <- read.csv("~/Downloads/RSEMisoforms.csv")
# transform transcript IDs' type from factor to character
ophrys$transcript_id <- as.character(ophrys$transcript_id)
library(data.table)
# create vector of unique gene IDs
genes <- as.data.frame(unique(ophrys$gene_id))
names(genes) <- "gene.id"
n <- length(genes$gene.id)
i <- 1 # index
d <- list() # list for storing transcript IDs
system.time(while (i <= n) # for each unique gene...
{
# temporary df of all transcripts for a given gene (usually just one line)
temp <- ophrys[which(ophrys$gene_id%in%genes$gene.id[i]),]
# sort `temp` by FPKM value, so that first row is transcript w/ largest FPKM
temp <- temp[with(temp, order(-FPKM)),]
# collect that first row
# (hooray, now you have the transcript with the highest FPKM value for that gene!)
d[[i]] <- as.data.frame(temp[1,1])
i <- i + 1
}) # takes a while because loops are very slow in R...
transcripts <- as.data.frame(rbindlist(d))
names(transcripts) <- "transcripts"
View(transcripts)
write.csv(transcripts, file="transcript-ids.csv", row.names=FALSE, fileEncoding="UTF-8")
getwd()
install.packages("knitr")
require(Rmd)
install.packages("Rmd")
install.packages("Rmarkdown")
require(md)
install.packages("md")
require(rmarkdown)
install.packages("rmarkdown")
install.packages("pandoc")
require(pandoc)
install.packages("markdown")
require(markdown)
require(markdown)
?md
?markdown
setwd("~/aussie-astioids")
getwd()
setwd()
H
getwd()
getwd()
setwd("/home/sam")
getwd()
install.packages("png")
install.packages("jpeg")
?jpeg
require(jpeg)
require(meme)
require(memes)
install.packages("memes")
install.packages("meme")
if(!require("devtools")) install.packages("devtools")
library("devtools")
install_github("leeper/meme")
install.packages("devtools")
library("meme")
require("devtools")
install.packages("curl-dev")
install.packages("curl-devel")
require(ggplot2)
?shape
?scale_color_manual
attributes(cars)
TRUE <- 1
T <- 1
T
T <- FALSE
T
is.true(T)
typeof(T)
x <- c(34,45,32,7)
x(c(-1,-2))
x[c(-1,-2)]
y <- 10
f1 <- function(x) {
function() {
x + 10
}
}
f1(1)()
f1(1)
f1(1)()
f1()(1)
f1(1)(1)
f1(1)()
?typeof
?is.list()
?sd
PREY_L <- vector(mode="numeric", length=50)
PREY_L <- seq(1,100,1)
PREY_L <- rep(PREY_L, 2)
PREY_L <- sort(PREY_L)
PREY_L <- vector(mode="numeric", length=50)
PREY_L <- seq(2,100,2)
PREY_L <- rep(PREY_L, 2)
PREY_L <- sort(PREY_L)
library(data.table)
?rbindlist
?sweep
setwd("/home/sam/Dropbox/github/coffee-data")
#setwd("wherever you put this file after downloading it")
library(ggplot2)
df <- read.csv("coffee-data.csv")
rate.date <- ggplot(df, aes(date, rate)) +
geom_point() +
stat_smooth(method="loess") +
xlab("date") +
ylab("rate of coffee dispensation (ml/second)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
theme_bw()
rate.date <- rate.date +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x=mean(df$duration)-5,y=min(df$volume),label="(machine warmup before dispensed)"),
hjust=0,vjust=0.5,color="red",size=4)
# print plot in R window
rate.date
max(df$rate)
rate.date <- ggplot(df, aes(date, rate)) +
geom_point() +
stat_smooth(method="loess") +
xlab("date") +
ylab("rate of coffee dispensation (ml/second)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
theme_bw()
rate.date <- rate.date +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x="05 Mar 2015",y=max(df$rate)+0.2,label="(machine warmup before dispensed)"),
hjust=0,vjust=0.5,color="red",size=4)
# print plot in R window
rate.date
rate.date <- ggplot(df, aes(date, rate, group=1)) +
geom_point() +
stat_smooth(method="loess") +
xlab("date") +
ylab("rate of coffee dispensation (ml/second)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
theme_bw()
rate.date <- rate.date +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x="05 Mar 2015",y=max(df$rate)+0.2,label="(machine warmup before dispensed)"),
hjust=0,vjust=0.5,color="red",size=4)
# print plot in R window
rate.date
?geom_hline
rate.date <- ggplot(df, aes(date, rate, group=1)) +
geom_point() +
geom_hline(aes(yintercept=mean(df$rate),linetype="dashed")) +
stat_smooth(method="loess") +
xlab("date") +
ylab("rate of coffee dispensation (ml/second)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
theme_bw()
rate.date <- rate.date +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x="05 Mar 2015",y=max(df$rate)+0.2,label="(machine warmup before dispensed)"),
hjust=0,vjust=0.5,color="red",size=4)
# print plot in R window
rate.date
# save plot directly to file as a .jpeg
jpeg("coffee-rate-vs-date.jpeg", width=7, height=5, units="in", res=300)
print(rate.date)
dev.off()
rate.date <- ggplot(df[df$warmup%in%"no",], aes(date, rate, group=1)) +
geom_point() +
geom_hline(aes(yintercept=mean(df$rate),linetype="dashed")) +
stat_smooth(method="loess") +
xlab("date") +
ylab("rate of coffee dispensation (ml/second)") +
theme(axis.text=element_text(size=4), axis.title=element_text(size=5)) +
theme_bw()
rate.date <- rate.date +
geom_point(data=df[df$warmup%in%"yes",], color="red", size=2.5) +
geom_text(aes(x="05 Mar 2015",y=max(df$rate)+0.2,label="(machine warmup before dispensed)"),
hjust=0,vjust=0.5,color="red",size=4)
# print plot in R window
rate.date
?axis.text.c
?axis.text.x
